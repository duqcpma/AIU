package aiumain;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;


/**
 *
 * @author Adam
 */
public class AIUTree<K extends Comparable> {
    
    protected Node<K> root = null;

    public int height() {
        return height(root);
    }

    private int height(Node<K> root) {
        return root == null ? 0 : 1 + Math.max(height(root.left), height(root.right));
    }

    public int size() {
        return size(root);
    }

    private int size(Node<K> root) {
        return root == null ? 0 : 1 + size(root.left) + size(root.right);
    }

    public Student find(K key) {
        return find(key, root);
    }

    private Student find(K key, Node<K> root) {
        if(root == null)
            return null;
        int c = key.compareTo(root.key); 
        if(c == 0)
            return root.data;
        else if(c < 0) 
            return find(key, root.left);
         else // c > 0
            return find(key, root.right);
    }

    public void add(K key, Student data) {
        root = add(key, data, root);
    }

    private Node<K> add(K key, Student data, Node<K> root) {
        // returns the tree with the added record.
        if(root == null)
            return new Node<K>(key,data);
        int c = key.compareTo(root.key); 
        
       //if(c == 0) {
         //   System.err.println("Error: duplicate key: " + key);
           // System.exit(1);
            //return null;
        //}
        
        if(c <= 0) {
            root.left =  add(key, data, root.left);
            return root;
        }
        else { // c > 0
            root.right = add(key, data, root.right);
            return root;
        }
    }

    public void modify(K key, Student data) {
        modify(key, data, root);
    }

    private void modify(K key, Student data, Node<K> root) {
        if(root == null) {
            System.err.println("Error: key not found: " + key);
            System.exit(1);
        }
         int c = key.compareTo(root.key);
        if(c == 0)
            root.data = data;
        else if(c < 0) 
            modify(key, data, root.left);
        else // c > 0
            modify(key, data, root.right);
    }

    @Override
    public String toString() {
      return toString(root);
    }

    private String toString(Node<K> root) {
        if(root == null)
            return "";
        return toString(root.left) + "(" + root.key + "," + root.data + ")" + toString(root.right);
    }

    public Node<K> leftmost(Node<K> root) {
 // Assume root is not null.
        if(root.left == null)
            return root;
        else
            return leftmost(root.left);
    }

    private Pair<Node<K>,Node<K>> findAndRemoveLeftmost(Node<K> root) {
 // Assume root is not null.
 // Returns the leftmost node and the tree with that node deleted.
        if(root.left == null)
            return new Pair<Node<K>,Node<K>>(root, root.right);
        else {
            Pair<Node<K>,Node<K>> pair = findAndRemoveLeftmost(root.left);
            Node<K> leftmost = pair.first;
            Node<K> newTree = pair.second;
            root.left = newTree;
            return new Pair<Node<K>,Node<K>>(leftmost, root);
        }
    }

    public void remove(K key) {
        root = remove(key, root);
    }

    private Node<K> remove(K key, Node<K> root) {
        if(root == null) {
            System.err.println("Error: key not found: " + key);
            System.exit(1);
            return null;
        }
        int c = key.compareTo(root.key); 
        if(c == 0) {
            if(root.left == null)
                return root.right;
            else if(root.right == null)
                return root.left;
            else { // two children, replace with leftmost node of right subtree.
                Pair<Node<K>,Node<K>> pair = findAndRemoveLeftmost(root.right);
                Node<K> leftmost = pair.first;
                Node<K> newRight = pair.second;
                leftmost.left = root.left;
                leftmost.right = newRight;
                return leftmost;
            }
        }
        else if(c < 0) {
            root.left = remove(key, root.left);
            return root;
        }
        else { // c > 0
            root.right = remove(key, root.right);
            return root;
        }
    }
    
    public void printTree(){
        AIUTreeIterator iterator = new AIUTreeIterator(this);
        try {
 
            String content = "";
   
            while(iterator.hasNext()){
                Node<K> currNode = iterator.next();
                content = content + currNode.data.lastName + "," + currNode.data.lastName + "," + currNode.data.firstName + "," + currNode.data.phoneNumber + "," + currNode.data.emailAddress + "," + currNode.data.goal.goal + System.getProperty("line.separator");
            }
    
            File file = new File("C:\\Users\\Adam\\Google Drive\\database.txt");
 
            // if file doesnt exists, then create it
            if (!file.exists()) {
            file.createNewFile();
            }
 
            FileWriter fw = new FileWriter(file.getAbsoluteFile());
            BufferedWriter bw = new BufferedWriter(fw);
            bw.write(content);
            bw.close();
 
            System.out.println("Done");
 
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
}
